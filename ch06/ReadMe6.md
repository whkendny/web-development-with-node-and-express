#### 第六章 请求和响应对象
**说明**: 在用Express构建Web服务器时，大部分工作是从**请求对象开始**，到**响应对象终止**。这个两个对象起源于Node,Express对其进行了扩展。

###### 一. URL的组成部分

![](http://img.mukewang.com/571b0c460001a03615950450.jpg)

1.1 **协议 (protocol)**: 协议确定如何传输请求。
> 主要是处理**http**和**https**。其他常见的协议还有file 和ftp。

1.2 **主机名（hostname）**: 主机名标识服务器。
- 运行在本地计算机（localhost）和本地网络的服务器可以简单地表示，比如用一个单词，或一个数字 IP 地址。
- 在 Internet 环境下，主机名通常以一个顶级域名（TLD）结尾，比如 .com 或 .net。另外，也许还会有子域名作为主机名的前缀。请求和响应对象子域名可以是任何形式的，其中 www 最为常见。子域名通常是可选的。

1.3 **端口(port)**： 每一台服务器都有一系列端口号。
- 一些端口号比较“特殊”，如 80 和 443 端口。如果省略端口值，那么默认 80 端口负责 HTTP 传输，443 端口负责 HTTPS 传输。
- 如果不使用 80 和 443 端口，就需要一个大于 10231的端口号。

1.4 **路径（path）**： URL 中影响应用程序的第一个组成部分通常是路径（在考虑协议、主机名和端口的基础上做决定很合理，但是不够好）。路径是应用中的页面或其他资源的唯一标识。

1.5 **查询字符串(querystring)**：查询字符串是一种键值对集合，是可选的。
- 它以问号（?）开头，键值对则以与号（&）分隔开。所有的名称和值都必须是 URL 编码的。对此，JavaScript 提供了一个嵌入式的函数 encodeURIComponent 来处理。
> 例如，空格被加号（+）替换。其他特殊字符被数字型字符替换。

1.6 **信息片段（fragment）**: 信息片段（或散列）被严格限制在浏览器中使用，不会传递到服务器。
- 用它控制单页应用或 AJAX 富应用越来越普遍。
- 最初，信息片段只是用来让浏览器展现文档中通过锚点标记（<a id="chapter06">）指定的部分。

##### 二 HTTP请求方法
**HTTP 协议确定了客户端与服务器通信的请求方法集合（通常称为 HTTP verbs）**
- GET和POST的方法最常见
- 在浏览器中键入一个 URL（或点击一个链接），服务器会接收到一个 HTTP GET 请求，其中的重要信息是 URL 路径和查询字符串。至于如何响应，则需要应用程序结合方法、路径和查询字符串来决定。
- 对于一个网站来说，大部分页面都响应 GET 请求。POST 请求通常用来提交信息到服务器后台（例如表单处理）。
- 服务器将请求中包含的所有信息（例如表单）处理完成之后，用以响应的 HTML 通常与相应的 GET 请求是一样的。与服务器通信时，浏览器只使用 GET 和POST 方法（如果没有使用 AJAX）。
- 另一方面，网络服务通常会使用更多的创造性 HTTP 方法。例如，一个 HTTP 方法被命名注 1： 0~1023 端口为“知名端口”。为 DELETE，它就用来接受 API 指令执行删除功能。
- 使用 Node 和 Express，可以完全掌控响应方法（尽管一些更复杂的方法支持得不是很好）。在 Express 中，通常要针对特殊方法编写处理程序。

##### 三. 请求报头
- 我们浏览网页时，发送到服务器的并不只是 URL。当你访问一个网站时，浏览器会发送很多**“隐形”信息**。
- 服务器会因此得知优先响应哪种语言的页面（例如，在西班牙下载 Chrome 浏览器，如果有西班牙语的版本，就会接收到一个西班牙语的访问页面）。它也会发送“用户代理”信息（浏览器、操作系统和硬件设备）和其他一些信息。
- 所有能够确保你了解请求对象头文件属性的信息都将会作为请求报头发送。
- 如果想查看浏览器发送的信息，可以创建一个非常简单的 Express 路由来展示一下：
``` JavaScript
app.get('/headers', function(req,res){
  res.set('Content-Type','text/plain');
  var s = '';
  for(var name in req.headers) s += name + ': ' + req.headers[name] + '\n';
  res.send(s);
});
```

##### 四. 响应报头
- 正如浏览器以请求报头的形式发送隐藏信息到服务器，当服务器响应时，同样会回传一些**浏览器没必要渲染和显示的信息**，通常是**元数据**和**服务器信息**。
**响应报头** 主要包含的信息：
> - 内容类型头信息；
> - 指出响应信息是否被压缩；
> - 使用的是哪种编码
等等

- 响应报头还可以包含关于浏览器对资源缓存时长的提示。优化网站时需要着重考虑这一点。响应报头还经常会包含一些关于服务器的信息，一般会指出服务器的类型，有时甚至会包含操作系统的详细信息。
- 返回服务器信息存在一个问题，那就是它会给黑客一个可乘之机，从而使站点陷入危险。非常重视安全的服务器经常忽略此信息，甚至提供虚假信息。禁用 Express 的 X-Powered-By 头信息很简单：`app.disable('x-powered-by');`

##### 五. 互联网媒体类型
- 内容类型报头信息极其重要，没有它，客户端很难判断如何渲染接收到的内容。
- 内容类型报头就是一种**互联网媒体类型** 由： **一个类型**、**一个子类型** 以及 **可选的参数** 组成。
> - 例如，`text/html;charset=UTF-8` 说明类型是 text，子类型是 html，字符编码是 UTF-8。

- 互联网编号分配机构维护了一个官方的[互联网媒体类型清单](http://www.iana.org/assignments/media-types/media-types.xhtml);
- 常见的 content type、Internet media type 和 MIME type 是可以互换的。MIME（多用途互联网邮件扩展）是互联网媒体类型的前身，它们大部分是相同的。

##### 六. 请求体
除请求报头外，请求还有一个**主体（就像作为实际内容返回的响应主体一样）** 。
- 一般 GET请求没有主体内容，但 POST 请求是有的。POST 请求体最常见的媒体类型是 `application/x-www-form-urlendcoded`，**是键值对集合的简单编码**，用 & 分隔（基本上和查询字符串的格式一样）。
- 如果 POST 请求需要支持文件上传，则媒体类型是`multipart/form-data`，它是一种更为复杂的格式。最后是 AJAX 请求，它可以使用 application/json。

##### 七. 参数
- “参数”这个词可以有很多种解释，它通常是困惑的源头。对于任何一个请求，参数可以来自查询字符串、会话、请求体或指定的路由参数。
- 在 Node 应用中，请求对象的参数方法会重写所有的参数。因此我们最好不要深究。通常这会带来问题，一个参数在查询字符串中，另一个在 POST 请求体中或会话中，哪个会赢呢？这会产生让人抓狂的 bug。PHP 是产生这种混乱的主要原因：为了尽量“方便”，它将所有参数重新写入了一个称为 `$_REQUEST` 的变量，由于某种原因，人们曾认为这是个前所未有的好主意。我们将学习保存不同类型参数的专用属性，我认为这能够减少困惑。

##### 八. 请求对象
- 请求对象（通常传递到回调方法，这意味着你可以随意命名，通常命名为 req 或 request）的生命**周期始于 Node** 的一个核心对象 `http.IncomingMessage` 的实例。Express 添加了一些附加功能。
- 我们来看看请求对象中最有用的属性和方法（除了来自 Node 的 req.headers 和req.url，所有这些方法都由 Express 添加）。

| 属性/方法       |  功能                                   |              注释         |
| -----------    |       ----------------------            | ----------------------------|  
| req.params     | 一个数组，包含命名过的路由参数。           |                            |
| req.param(name)| 返回命名的路由参数，或者 GET 请求或 POST 请求参数。|  建议忽略此方法。  |
| req.query    |  一个对象，包含以键值对存放的查询字符串参数（通常称为 GET 请求参数）||
| req.body     | 一个对象，包含 POST 请求参数。这样命名是因为 POST 请求参数在 REQUEST 正文中传递，而不像查询字符串在 URL 中传递。要使 req.body 可用，需要中间件能够解析请求正文内容类型| |
| req.route    | 关于当前匹配路由的信息                  | 主要用于路由调试。  |
|req.cookies/req.singnedCookies| 一个对象，包含从客户端传递过来的 cookies 值， 从客户端接收到的请求报头| |
|req.accepts([types]) |一个简便的方法，用来确定客户端是否接受一个或一组指定的类型（可选类型可以是单个的 MIME 类型，如 application/json、一个逗号分隔集合或是一个数组）|写公共API 的人对该方法很感兴趣。假定浏览器默认始终接受 HTML|
|req.ip  | 客户端的 IP 地址 |  |
|req.path | 请求路径（不包含协议、主机、端口或查询字符串） |   |
|req.host|一个简便的方法，用来返回客户端所报告的主机名 | 这些信息可以伪造，所以不应该用于安全目的 |
|req.xhr |一个简便属性，如果请求由 Ajax 发起将会返回 true|  |
|req.protocol|用于标识请求的协议（http 或 https）|   |
|req.secure|一个简便属性，如果连接是安全的，将返回 true| req.protocol==='https'|
|req.url/req.originalUrl | 有点用词不当，这些属性返回了路径和查询字符串（它们不包含协议、主机或端口）。req.url 若是出于内部路由目的，则可以重写，但是 req.orginalUrl 旨在保留原始请和查询字符串 |   |      
| req.acceptedLanguages | 一个简便方法，用来返回客户端首选的一组（人类的）语言 | 这些信息是从请求报头中解析而来的。 |
##### [响应对象](http://blog.csdn.net/christine95/article/details/50500171)
